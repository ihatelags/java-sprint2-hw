# ТЗ: «Трекер задач».

## Типы задач

Простейшим кирпичиком такой системы является задача (англ. task). У задачи есть следующие свойства:

* Название, кратко описывающее суть задачи (например, «Переезд»).
* Описание, в котором раскрываются детали.
* Уникальный идентификационный номер задачи, по которому её можно будет найти.
* tasks.Статус, отображающий её прогресс. Мы будем выделять следующие этапы жизни задачи:
1. NEW — задача только создана, но к её выполнению ещё не приступили.
2. IN_PROGRESS — над задачей ведётся работа.
3. DONE — задача выполнена.

Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на подзадачи (англ. subtask). Большую задачу, которая делится на подзадачи, мы будем называть эпиком (англ. epic).
Таким образом, в нашей системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи. Для них должны выполняться следующие условия:

* Для каждой подзадачи известно, в рамках какого эпика она выполняется.
* Каждый эпик знает, какие подзадачи в него входят.
* Завершение всех подзадач эпика считается завершением эпика.

## managers.InMemoryTasksManager

Кроме классов для описания задач, вам нужно реализовать класс для объекта-менеджера. Он будет запускаться на старте программы и управлять всеми задачами. В нём должны быть реализованы следующие функции:

1. Возможность хранить задачи всех типов. Для этого вам нужно выбрать подходящую коллекцию.
2. Методы:
    1. Получение списка всех задач.
    2. Получение списка всех эпиков.
    3. Получение списка всех подзадач определённого эпика.
    4. Получение задачи любого типа по идентификатору.
    5. Добавление новой задачи, эпика и подзадачи. Сам объект должен передаваться в качестве параметра.
    6. Обновление задачи любого типа по идентификатору. Новая версия объекта передаётся в виде параметра.
    7. Удаление ранее добавленных задач — всех и по идентификатору.
3. Управление статусами осуществляется по следующему правилу:
    1. managers.InMemoryTasksManager сам не выбирает статус для задачи. Информация о нём приходит менеджеру вместе с информацией о самой задаче.
    2. Для эпиков:
        * если у эпика нет подзадач или все они имеют статус NEW, то статус должен быть NEW.
        * если все подзадачи имеют статус DONE, то и эпик считается завершённым — со статусом DONE.
        * во всех остальных случаях статус должен быть IN_PROGRESS.

# managers.interfaces.TaskManager теперь интерфейс

Из темы об абстракции и полиморфизме вы узнали, что при проектировании кода полезно разделять требования к желаемой функциональности объектов и то, как эта функциональность реализована. То есть набор методов, который должен быть у объекта, лучше вынести в интерфейс, а реализацию этих методов - в класс, который его реализует. Теперь нужно применить этот принцип к менеджеру задач.

1. Класс `TaskManager` должен стать интерфейсом. В нём нужно собрать список методов, которые должны быть у любого объекта-менеджера.  Вспомогательные методы, если вы их создавали, переносить в интерфейс не нужно.
2. Созданный ранее класс менеджера нужно переименовать в `InMemoryTaskManager`. Именно то, что менеджер хранит всю информацию в оперативной памяти, и есть его главное свойство, позволяющее эффективно управлять задачами. Внутри класса должна остаться реализация методов. При этом важно не забыть имплементировать `TaskManager` — в Java класс должен явно заявить, что он подходит под требования интерфейса.


### История просмотров задач

Добавьте в программу новую функциональность — нужно, чтобы трекер отображал последние просмотренные пользователем задачи. Для этого реализуйте метод `getHistory()` — он должен возвращать последние 10 просмотренных задач. Просмотром будет считаться вызов у менеджера методов получения задачи по идентификатору  — `getTask(),` `getSubtask()` и `getEpic()`. От повторных просмотров избавляться не нужно.

У метода `getHistory()` не будет параметров. Это значит, он формирует свой ответ, анализируя исключительно внутреннее состояние полей объекта менеджера. Подумайте, каким образом и какие данные вы запишете в поля менеджера для возможности извлекать из них историю посещений. Так как в истории отображается, к каким задачам было обращение в методах `getTask(),` `getSubtask()` и `getEpic()`, эти данные в полях менеджера будут обновляться при вызове этих трех методов.

Обратите внимание, что просмотрен может быть любой тип задачи. То есть возвращаемый список задач может содержать объект одного из трех типов на любой своей позиции. Чтобы описать ячейку такого списка, нужно вспомнить о полиморфизме и выбрать тип, являющийся общим родителем обоих классов.
Проверьте, что история возвращает только существующие задачи. Если задача удалена, ее нужно удалить из истории.


### Утилитарный класс

Со временем в приложении трекера появится несколько реализаций интерфейса `TaskManager`.   Чтобы не зависеть от реализации, создайте утилитарный класс `Managers`.  На нём будет лежать вся ответственность за создание менеджера задач. То есть `Managers` должен сам подбирать нужную реализацию `TaskManager`и возвращать объект правильного типа.
У `Managers`будет единственные метод  `getDefault()`.  При этом вызывающему неизвестен конкретный класс, только то, что объект, который возвращает `getDefault()`, реализует интерфейс `TaskManager`.


### Статусы задач как перечисление

Так как варианты возможных статусов у задачи ограничены, для их хранения в программе лучше завести перечисляемый тип `enum`.


### Тестирование вашего решения

Убедитесь, что ваше решение работает! В главном классе воспроизведите несложный пользовательский сценарий:

- создайте несколько задач разного типа.
- вызовите разные методы интерфейса `TaskManager` и напечатайте историю просмотров после каждого вызова. Если код рабочий, то история просмотров задач будет отображаться корректно.

### Сделайте историю задач интерфейсом

В этом спринте возможности трекера ограничены — в истории просмотров допускается дублирование и она может содержать только десять задач. В следующем спринте вам нужно будет убрать дубли и расширить её размер. Чтобы подготовиться к этому, проведите рефакторинг кода.

Создайте отдельный интерфейс для управления историей просмотров — `HistoryManager`. У него будет два метода. Первый `add(Task task)` должен помечать задачи как просмотренные, а второй `getHistory()` — возвращать их список.

Объявите класс `InMemoryHistoryManager` и перенесите в него часть кода для работы с историей из  класса `InMemoryTaskManager`.  Новый класс `InMemoryHistoryManager` должен реализовывать интерфейс `HistoryManager`.

Добавьте в служебный класс `Managers` статический метод `HistoryManager getDefaultHistory()`.  Он должен возвращать объект `InMemoryHistoryManager` — историю просмотров.

Проверьте, что теперь `InMemoryTaskManager` обращается к менеджеру истории через интерфейс `HistoryManager` и использует реализацию, которую возвращает метод `getDefaultHistory()`.

## Спринт 4

Пришло время потренироваться и усовершенствовать код трекера с помощью полученных знаний о списках и хеш-таблицах! В этом спринте вам предстоит поработать с историей просмотров задач, а именно избавиться от повторных просмотров в ней и ограничения на размер истории. Поехали!

### Обратите внимание
Недостаточно реализовать код таким образом, чтобы программа пробегалась по всей истории просмотров и только после этого удаляла предыдущий просмотр. Ведь тогда время работы этой программы будет линейно зависеть от длины истории.
Ваша цель — реализовать функциональность так, чтобы время просмотра задачи никак не зависело от общего количества задач в истории.

### Интерфейс HistoryManager
У нас уже есть интерфейс, осталось добавить метод void remove(int id) для удаления задачи из просмотра. И реализовать его в классе InMemoryHistoryManager. Добавьте его вызов при удалении задач, чтобы они также удалялись из истории просмотров.

### Дальнейшая разработка алгоритма с CustomLinkedList и HashMap

Программа должна запоминать порядок вызовов метода add, ведь именно в этом порядке просмотры будут выстраиваться в истории. Для хранения порядка вызовов удобно использовать список.

Если какая-либо задача просматривалась несколько раз, в истории должен отобразиться только последний просмотр. Предыдущий просмотр должен быть удалён сразу же после появления нового — за O(1). Из темы о списках вы узнали, что константное время выполнения операции может гарантировать связный список CustomLinkedList. Однако его стандартная реализация в данном случае не подойдёт. Поэтому вам предстоит написать собственную.

CustomLinkedList позволяет удалить элемент из произвольного места за О(1) с одним важным условием — если программа уже дошла до этого места по списку. Чтобы выполнить условие, создайте стандартную HashMap. Её ключом будет id задачи, просмотр которой требуется удалить, а значением — место просмотра этой задачи в списке, то есть узел связного списка. С помощью номера задачи можно получить соответствующий ему узел связного списка и удалить его.

Реализация метода getHistory должна перекладывать задачи из связного списка в ArrayList для формирования ответа.

## Спринт 5

## Вторая реализация менеджера

Итак, создайте класс `FileBackedTasksManager`. В нём вы будете прописывать логику автосохранения в файл. Этот класс, как и `InMemoryTasksManager`, должен имплементировать интерфейс менеджера `TasksManager`.

Теперь нужно написать реализацию для нового класса. Если у вас появится желание просто скопировать код из `InMemoryTasksManager` и дополнить его в нужных местах функцией сохранения в файл, остановитесь! Старайтесь избегать дублирования кода, это признак плохого стиля.

В данном случае есть более изящное решение: можно наследовать `FileBackedTasksManager` от `InMemoryTasksManager` и получить от класса-родителя желаемую логику работы менеджера. Останется только дописать в некоторых местах вызовы метода автосохранения.

## Метод автосохранения

Пусть новый менеджер получает файл для автосохранения в своём конструкторе и сохраняет его в поле. Создайте метод `save` без параметров — он будет сохранять текущее состояние менеджера в указанный файл.

Теперь достаточно переопределить каждую модифицирующую операцию таким образом, чтобы сначала выполнялась версия, унаследованная от предка, а затем — метод `save`. Например:

```
@Override
public void addSubtask(Subtask subtask) {
    super.addSubtask(subtask);
    save();
}

```

Затем нужно продумать логику метода `save`. Что он должен сохранять? Все задачи, подзадачи, эпики и историю просмотра любых задач. Для удобства работы рекомендуем выбрать текстовый формат CSV (англ. *Comma-Separated Values*, «значения, разделённые запятыми»). Тогда файл с сохранёнными данными будет выглядеть так:

```jsx
id,type,name,status,description,epic
1,TASK,Task1,NEW,Description task1,
2,EPIC,Epic2,DONE,Description epic2,
3,SUBTASK,Sub Task2,DONE,Description sub task3,2

2,3
```

Сначала через запятую перечисляются все поля задач. Ниже находится список задач, каждая из них записана с новой строки. Дальше — пустая строка, которая отделяет задачи от истории просмотров. И заключительная строка — это идентификаторы задач из истории просмотров.

Файл из нашего примера можно прочитать так: в трекер добавлены задача, эпик и подзадача. Эпик и подзадача просмотрены и выполнены. Задача осталась в состоянии новой и не была просмотрена.

- **Подсказка: Как сохранять задачи в файл и считывать их из него**
    - Создайте enum с типами задач.
    - Напишите метод сохранения задачи в строку `String toString(Task task)` или переопределите базовый.
    - Напишите метод создания задачи из строки `Task fromString(String value)`.
    - Напишите статические методы `static String toString(HistoryManager manager)` и `static List<Integer> fromString(String value)` для сохранения и восстановления менеджера истории из CSV.
- **Подсказка: Как прочитать файл**

  В Java есть несколько способов чтения файлов. Вы можете использовать такой:

    ```jsx
    Files.readString(file.toPath());
    ```


## Проверка работы нового менеджера

Исключения вида `IOException` нужно отлавливать внутри метода `save` и кидать собственное непроверяемое исключение `ManagerSaveException`. Благодаря этому можно не менять сигнатуру методов интерфейса менеджера.

<aside>
💡 Мы исходим из того, что наш менеджер работает в идеальных условиях. Над ним не совершаются недопустимые операции, и все его действия со средой (например, сохранение файла) завершаются успешно.

</aside>

Помимо метода сохранения создайте статический метод `static FileBackedTasksManager`  `loadFromFile(File file)`, который будет восстанавливать данные менеджера из файла при запуске программы. Не забудьте убедиться, что новый менеджер задач работает так же, как предыдущий. И проверьте работу сохранения и восстановления менеджера из файла (сериализацию).

Для этого создайте метод `static void main(String[] args)` в классе `FileBackedTasksManager` и реализуйте небольшой сценарий:

1. Заведите несколько разных задач, эпиков и подзадач.
2. Запросите некоторые из них, чтобы заполнилась история просмотра.
3. Создайте новый `FileBackedTasksManager` менеджер из этого же файла.
4. Проверьте, что история просмотра восстановилась верно и все задачи, эпики, подзадачи, которые были в старом, есть в новом менеджере.